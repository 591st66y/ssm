<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 缓存管理器 使用Ehcache实现 -->
    <bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager">
        <property name="cacheManagerConfigFile" value="classpath:ehcache.xml"/>
    </bean>

    <!-- 凭证匹配器 -->
    <bean id="credentialsMatcher" class="com.coderman.common.shiro.credentials.RetryLimitHashedCredentialsMatcher">
        <constructor-arg ref="cacheManager"/>
        <property name="hashAlgorithmName" value="md5"/>
        <property name="hashIterations" value="1024"/>
        <property name="storedCredentialsHexEncoded" value="true"/>
    </bean>

    <!--自定义realm-->
    <bean id="userRealm" class="com.coderman.common.shiro.realm.UserRealm">
        <property name="credentialsMatcher" ref="credentialsMatcher"/>
        <property name="cachingEnabled" value="true"/>
        <property name="authenticationCachingEnabled" value="true"/>
        <property name="authenticationCacheName" value="authenticationCache"/>
        <property name="authorizationCachingEnabled" value="true"/>
        <property name="authorizationCacheName" value="authorizationCache"/>
    </bean>


    <!-- 配置shiro的一些拦截规则，id必须和web.xml中的 shiro 拦截器名一致 -->
    <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <!-- Shiro的核心安全接口,这个属性是必须的 -->
        <property name="securityManager" ref="securityManager"/>
        <!-- 身份认证失败，则跳转到登录页面的配置 -->
        <property name="loginUrl" value="/system/loginPage.do"/>
        <!-- 登录成功后的页面:(后台主页面) -->
<!--        <property name="successUrl" value="/system/mainPage.do"/>-->
        <!-- 登录后访问没有权限的页面后跳转的页面 -->
        <property name="unauthorizedUrl" value="/unauthorizedPage.do"/>
        <!-- Shiro连接约束配置,即过滤链的定义 -->
        <property name="filterChainDefinitions">
            <value>
                <!-- 注意：规则是有顺序的，从上到下，拦截范围必须是从小到大的 -->
                <!--  url = 拦截规则（anon为匿名，authc为要登录后，才能访问，logout登出过滤） -->
                /system/loginPage.do = anon
                /system/user/login.do = anon
                /system/user/captcha.do = anon
                /system/** = authc
            </value>
        </property>
        <property name="filters">
            <map>
                <!--定义自己的loginFilter:覆盖之前的-->
                <entry key="authc" value-ref="restLoginAuthorizationFilter"/>
            </map>
        </property>
    </bean>
    <!--解决前后端(页面跳转问题)跳转页面的filter-->
    <bean id="restLoginAuthorizationFilter" class="com.coderman.common.shiro.filter.RestLoginAuthorizationFilter"/>

    <!-- 配置 shiro 的核心组件：securityManager -->
    <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="realms">
            <list><ref bean="userRealm"/></list>
        </property>
        <property name="sessionManager" ref="sessionManager"/>
    </bean>

    <!--session 相关配置-->
    <bean id="sessionDAO" class="org.apache.shiro.session.mgt.eis.MemorySessionDAO"/>
    <bean id="sessionManager" class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager">
        <property name="sessionDAO" ref="sessionDAO"/>
        <!-- 检测扫描信息时间间隔,单位为毫秒-->
        <property name="sessionValidationInterval" value="60000"/>
        <property name="sessionIdCookie" ref="simpleCookie"/>
        <!-- 是否开启扫描 -->
        <property name="sessionValidationSchedulerEnabled" value="true"/>
        <!-- 去掉URL中的JSESSIONID -->
        <property name="sessionIdUrlRewritingEnabled" value="true"/>
        <property name="globalSessionTimeout" value="3600000"/>
    </bean>

    <!-- sessionIdCookie的实现,用于重写覆盖容器默认的JSESSIONID -->
    <bean id="simpleCookie" class="org.apache.shiro.web.servlet.SimpleCookie">
        <!-- 设置Cookie名字, 默认为: JSESSIONID 问题: 与SERVLET容器名冲突, 如JETTY, TOMCAT 等默认JSESSIONID,
                                    当跳出SHIRO SERVLET时如ERROR-PAGE容器会为JSESSIONID重新分配值导致登录会话丢失! -->
        <property name="name" value="SHIRO-JSESSIONID"/>
        <!-- JSESSIONID的path为/用于多个系统共享JSESSIONID -->
        <!-- <property name="path" value="/"/> -->
        <!-- 浏览器中通过document.cookie可以获取cookie属性，设置了HttpOnly=true,在脚本中就不能的到cookie，可以避免cookie被盗用 -->
        <property name="httpOnly" value="true"/>
    </bean>

</beans>
